/* cellrenderertextish.c generated by valac 0.56.0, the Vala compiler
 * generated from cellrenderertextish.vala, do not modify */

/* compile with valac -c cellrenderertextish.vala --pkg gtk+-3.0 --vapidir . --pkg input_inhibitor -C -H cellrenderertextish.h */

#include "cellrenderertextish.h"
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <cairo-gobject.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <input_inhibitor.h>

enum  {
	CELL_RENDERER_TEXTISH_0_PROPERTY,
	CELL_RENDERER_TEXTISH_ICON_PROPERTY,
	CELL_RENDERER_TEXTISH_NUM_PROPERTIES
};
static GParamSpec* cell_renderer_textish_properties[CELL_RENDERER_TEXTISH_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_CELL_EDITABLE_ACCEL (cell_editable_accel_get_type ())
#define CELL_EDITABLE_ACCEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel))
#define CELL_EDITABLE_ACCEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccelClass))
#define IS_CELL_EDITABLE_ACCEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_ACCEL))
#define IS_CELL_EDITABLE_ACCEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_ACCEL))
#define CELL_EDITABLE_ACCEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccelClass))

typedef struct _CellEditableAccel CellEditableAccel;
typedef struct _CellEditableAccelClass CellEditableAccelClass;

#define TYPE_CELL_EDITABLE_COMBO (cell_editable_combo_get_type ())
#define CELL_EDITABLE_COMBO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_COMBO, CellEditableCombo))
#define CELL_EDITABLE_COMBO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_COMBO, CellEditableComboClass))
#define IS_CELL_EDITABLE_COMBO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_COMBO))
#define IS_CELL_EDITABLE_COMBO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_COMBO))
#define CELL_EDITABLE_COMBO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_COMBO, CellEditableComboClass))

typedef struct _CellEditableCombo CellEditableCombo;
typedef struct _CellEditableComboClass CellEditableComboClass;

#define TYPE_CELL_EDITABLE_DUMMY (cell_editable_dummy_get_type ())
#define CELL_EDITABLE_DUMMY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy))
#define CELL_EDITABLE_DUMMY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummyClass))
#define IS_CELL_EDITABLE_DUMMY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_DUMMY))
#define IS_CELL_EDITABLE_DUMMY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_DUMMY))
#define CELL_EDITABLE_DUMMY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummyClass))

typedef struct _CellEditableDummy CellEditableDummy;
typedef struct _CellEditableDummyClass CellEditableDummyClass;
enum  {
	CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL,
	CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL,
	CELL_RENDERER_TEXTISH_NUM_SIGNALS
};
static guint cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_NUM_SIGNALS] = {0};
typedef struct _CellEditableDummyPrivate CellEditableDummyPrivate;
enum  {
	CELL_EDITABLE_DUMMY_0_PROPERTY,
	CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY,
	CELL_EDITABLE_DUMMY_NUM_PROPERTIES
};
static GParamSpec* cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_NUM_PROPERTIES];
typedef struct _CellEditableAccelPrivate CellEditableAccelPrivate;
enum  {
	CELL_EDITABLE_ACCEL_0_PROPERTY,
	CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY,
	CELL_EDITABLE_ACCEL_NUM_PROPERTIES
};
static GParamSpec* cell_editable_accel_properties[CELL_EDITABLE_ACCEL_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _CellEditableComboPrivate CellEditableComboPrivate;
enum  {
	CELL_EDITABLE_COMBO_0_PROPERTY,
	CELL_EDITABLE_COMBO_NUM_PROPERTIES
};
static GParamSpec* cell_editable_combo_properties[CELL_EDITABLE_COMBO_NUM_PROPERTIES];
typedef struct _Block1Data Block1Data;

struct _CellRendererTextishPrivate {
	GdkPixbuf* _icon;
	GtkCellEditable* cell;
};

struct _CellEditableDummy {
	GtkEventBox parent_instance;
	CellEditableDummyPrivate * priv;
};

struct _CellEditableDummyClass {
	GtkEventBoxClass parent_class;
	void (*start_editing) (CellEditableDummy* self, GdkEvent* event);
};

struct _CellEditableDummyPrivate {
	gboolean _editing_canceled;
};

struct _CellEditableAccel {
	GtkEventBox parent_instance;
	CellEditableAccelPrivate * priv;
};

struct _CellEditableAccelClass {
	GtkEventBoxClass parent_class;
	void (*start_editing) (CellEditableAccel* self, GdkEvent* event);
};

struct _CellEditableAccelPrivate {
	gboolean _editing_canceled;
	CellRendererTextish* parent;
	gchar* path;
};

struct _CellEditableCombo {
	GtkComboBoxText parent_instance;
	CellEditableComboPrivate * priv;
};

struct _CellEditableComboClass {
	GtkComboBoxTextClass parent_class;
	void (*start_editing) (CellEditableCombo* self, GdkEvent* event);
};

struct _CellEditableComboPrivate {
	CellRendererTextish* parent;
	gchar* path;
};

struct _Block1Data {
	int _ref_count_;
	CellEditableCombo* self;
	CellRendererTextish* parent;
	gchar* path;
};

static gint CellRendererTextish_private_offset;
static gpointer cell_renderer_textish_parent_class = NULL;
static gint CellEditableDummy_private_offset;
static gpointer cell_editable_dummy_parent_class = NULL;
static GtkCellEditableIface * cell_editable_dummy_gtk_cell_editable_parent_iface = NULL;
static gint CellEditableAccel_private_offset;
static gpointer cell_editable_accel_parent_class = NULL;
static GtkCellEditableIface * cell_editable_accel_gtk_cell_editable_parent_iface = NULL;
static gint CellEditableCombo_private_offset;
static gpointer cell_editable_combo_parent_class = NULL;
static GtkCellEditableIface * cell_editable_combo_gtk_cell_editable_parent_iface = NULL;

static GtkCellEditable* cell_renderer_textish_real_start_editing (GtkCellRenderer* base,
                                                           GdkEvent* event,
                                                           GtkWidget* widget,
                                                           const gchar* path,
                                                           GdkRectangle* background_area,
                                                           GdkRectangle* cell_area,
                                                           GtkCellRendererState flags);
VALA_EXTERN CellEditableAccel* cell_editable_accel_new (CellRendererTextish* parent,
                                            const gchar* path,
                                            GtkWidget* widget);
VALA_EXTERN CellEditableAccel* cell_editable_accel_construct (GType object_type,
                                                  CellRendererTextish* parent,
                                                  const gchar* path,
                                                  GtkWidget* widget);
VALA_EXTERN GType cell_editable_accel_get_type (void) G_GNUC_CONST ;
VALA_EXTERN CellEditableCombo* cell_editable_combo_new (CellRendererTextish* parent,
                                            const gchar* path,
                                            GtkWidget* widget,
                                            gchar** items,
                                            gint items_length1);
VALA_EXTERN CellEditableCombo* cell_editable_combo_construct (GType object_type,
                                                  CellRendererTextish* parent,
                                                  const gchar* path,
                                                  GtkWidget* widget,
                                                  gchar** items,
                                                  gint items_length1);
VALA_EXTERN GType cell_editable_combo_get_type (void) G_GNUC_CONST ;
VALA_EXTERN CellEditableDummy* cell_editable_dummy_new (void);
VALA_EXTERN CellEditableDummy* cell_editable_dummy_construct (GType object_type);
VALA_EXTERN GType cell_editable_dummy_get_type (void) G_GNUC_CONST ;
static void cell_renderer_textish_real_render (GtkCellRenderer* base,
                                        cairo_t* ctx,
                                        GtkWidget* widget,
                                        GdkRectangle* background_area,
                                        GdkRectangle* cell_area,
                                        GtkCellRendererState flags);
static void cell_renderer_textish_real_get_size (GtkCellRenderer* base,
                                          GtkWidget* widget,
                                          GdkRectangle* cell_area,
                                          gint* x_offset,
                                          gint* y_offset,
                                          gint* width,
                                          gint* height);
static void cell_renderer_textish_real_get_preferred_height (GtkCellRenderer* base,
                                                      GtkWidget* widget,
                                                      gint* minimum_size,
                                                      gint* natural_size);
static void cell_renderer_textish_real_get_preferred_height_for_width (GtkCellRenderer* base,
                                                                GtkWidget* widget,
                                                                gint width,
                                                                gint* minimum_height,
                                                                gint* natural_height);
static void cell_renderer_textish_real_get_preferred_width (GtkCellRenderer* base,
                                                     GtkWidget* widget,
                                                     gint* minimum_size,
                                                     gint* natural_size);
static void cell_renderer_textish_real_get_preferred_width_for_height (GtkCellRenderer* base,
                                                                GtkWidget* widget,
                                                                gint height,
                                                                gint* minimum_width,
                                                                gint* natural_width);
static void g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT (GClosure * closure,
                                                      GValue * return_value,
                                                      guint n_param_values,
                                                      const GValue * param_values,
                                                      gpointer invocation_hint,
                                                      gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_UINT (GClosure * closure,
                                                GValue * return_value,
                                                guint n_param_values,
                                                const GValue * param_values,
                                                gpointer invocation_hint,
                                                gpointer marshal_data);
static void cell_renderer_textish_finalize (GObject * obj);
static GType cell_renderer_textish_get_type_once (void);
static void _vala_cell_renderer_textish_get_property (GObject * object,
                                               guint property_id,
                                               GValue * value,
                                               GParamSpec * pspec);
static void _vala_cell_renderer_textish_set_property (GObject * object,
                                               guint property_id,
                                               const GValue * value,
                                               GParamSpec * pspec);
VALA_EXTERN void cell_editable_dummy_start_editing (CellEditableDummy* self,
                                        GdkEvent* event);
static void cell_editable_dummy_real_start_editing (CellEditableDummy* self,
                                             GdkEvent* event);
VALA_EXTERN gboolean cell_editable_dummy_get_editing_canceled (CellEditableDummy* self);
VALA_EXTERN void cell_editable_dummy_set_editing_canceled (CellEditableDummy* self,
                                               gboolean value);
static void cell_editable_dummy_finalize (GObject * obj);
static GType cell_editable_dummy_get_type_once (void);
static void _vala_cell_editable_dummy_get_property (GObject * object,
                                             guint property_id,
                                             GValue * value,
                                             GParamSpec * pspec);
static void _vala_cell_editable_dummy_set_property (GObject * object,
                                             guint property_id,
                                             const GValue * value,
                                             GParamSpec * pspec);
VALA_EXTERN void cell_editable_accel_start_editing (CellEditableAccel* self,
                                        GdkEvent* event);
static void cell_editable_accel_on_editing_done (CellEditableAccel* self);
static void _cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done (GtkCellEditable* _sender,
                                                                          gpointer self);
static void cell_editable_accel_real_start_editing (CellEditableAccel* self,
                                             GdkEvent* event);
static gboolean cell_editable_accel_on_key (CellEditableAccel* self,
                                     GdkEventKey* event);
static gboolean _cell_editable_accel_on_key_gtk_widget_key_press_event (GtkWidget* _sender,
                                                                 GdkEventKey* event,
                                                                 gpointer self);
VALA_EXTERN gboolean cell_editable_accel_get_editing_canceled (CellEditableAccel* self);
VALA_EXTERN void cell_editable_accel_set_editing_canceled (CellEditableAccel* self,
                                               gboolean value);
static void cell_editable_accel_finalize (GObject * obj);
static GType cell_editable_accel_get_type_once (void);
static void _vala_cell_editable_accel_get_property (GObject * object,
                                             guint property_id,
                                             GValue * value,
                                             GParamSpec * pspec);
static void _vala_cell_editable_accel_set_property (GObject * object,
                                             guint property_id,
                                             const GValue * value,
                                             GParamSpec * pspec);
VALA_EXTERN void cell_editable_combo_start_editing (CellEditableCombo* self,
                                        GdkEvent* event);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda4_ (Block1Data* _data1_);
static void ___lambda4__gtk_combo_box_changed (GtkComboBox* _sender,
                                        gpointer self);
static void cell_editable_combo_real_start_editing (CellEditableCombo* self,
                                             GdkEvent* event);
static void cell_editable_combo_finalize (GObject * obj);
static GType cell_editable_combo_get_type_once (void);

static inline gpointer
cell_renderer_textish_get_instance_private (CellRendererTextish* self)
{
	return G_STRUCT_MEMBER_P (self, CellRendererTextish_private_offset);
}

static GType
cell_renderer_textish_mode_get_type_once (void)
{
	static const GEnumValue values[] = {{CELL_RENDERER_TEXTISH_MODE_Text, "CELL_RENDERER_TEXTISH_MODE_Text", "text"}, {CELL_RENDERER_TEXTISH_MODE_Key, "CELL_RENDERER_TEXTISH_MODE_Key", "key"}, {CELL_RENDERER_TEXTISH_MODE_Popup, "CELL_RENDERER_TEXTISH_MODE_Popup", "popup"}, {CELL_RENDERER_TEXTISH_MODE_Combo, "CELL_RENDERER_TEXTISH_MODE_Combo", "combo"}, {0, NULL, NULL}};
	GType cell_renderer_textish_mode_type_id;
	cell_renderer_textish_mode_type_id = g_enum_register_static ("CellRendererTextishMode", values);
	return cell_renderer_textish_mode_type_id;
}

GType
cell_renderer_textish_mode_get_type (void)
{
	static volatile gsize cell_renderer_textish_mode_type_id__once = 0;
	if (g_once_init_enter (&cell_renderer_textish_mode_type_id__once)) {
		GType cell_renderer_textish_mode_type_id;
		cell_renderer_textish_mode_type_id = cell_renderer_textish_mode_get_type_once ();
		g_once_init_leave (&cell_renderer_textish_mode_type_id__once, cell_renderer_textish_mode_type_id);
	}
	return cell_renderer_textish_mode_type_id__once;
}

CellRendererTextish*
cell_renderer_textish_construct (GType object_type)
{
	CellRendererTextish * self = NULL;
	self = (CellRendererTextish*) g_object_new (object_type, NULL);
	self->mode = CELL_RENDERER_TEXTISH_MODE_Text;
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	self->items = NULL;
	self->items_length1 = 0;
	return self;
}

CellRendererTextish*
cell_renderer_textish_new (void)
{
	return cell_renderer_textish_construct (TYPE_CELL_RENDERER_TEXTISH);
}

CellRendererTextish*
cell_renderer_textish_construct_with_items (GType object_type,
                                            gchar** items,
                                            gint items_length1)
{
	CellRendererTextish * self = NULL;
	self = (CellRendererTextish*) g_object_new (object_type, NULL);
	self->mode = CELL_RENDERER_TEXTISH_MODE_Text;
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	self->items = items;
	self->items_length1 = items_length1;
	return self;
}

CellRendererTextish*
cell_renderer_textish_new_with_items (gchar** items,
                                      gint items_length1)
{
	return cell_renderer_textish_construct_with_items (TYPE_CELL_RENDERER_TEXTISH, items, items_length1);
}

void
cell_renderer_textish_set_items (CellRendererTextish* self,
                                 gchar** items_,
                                 gint items__length1)
{
	g_return_if_fail (self != NULL);
	self->items = items_;
	self->items_length1 = items__length1;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static GtkCellEditable*
cell_renderer_textish_real_start_editing (GtkCellRenderer* base,
                                          GdkEvent* event,
                                          GtkWidget* widget,
                                          const gchar* path,
                                          GdkRectangle* background_area,
                                          GdkRectangle* cell_area,
                                          GtkCellRendererState flags)
{
	CellRendererTextish * self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GtkCellEditable* _tmp11_;
	GtkCellEditable* result;
	self = (CellRendererTextish*) base;
	g_return_val_if_fail (widget != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (background_area != NULL, NULL);
	g_return_val_if_fail (cell_area != NULL, NULL);
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	g_object_get ((GtkCellRendererText*) self, "editable", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	if (!_tmp1_) {
		GtkCellEditable* _tmp2_;
		_tmp2_ = self->priv->cell;
		result = _tmp2_;
		return result;
	}
	switch (self->mode) {
		case CELL_RENDERER_TEXTISH_MODE_Text:
		{
			GdkRectangle _tmp3_;
			GdkRectangle _tmp4_;
			GtkCellEditable* _tmp5_;
			GtkCellEditable* _tmp6_;
			_tmp3_ = *background_area;
			_tmp4_ = *cell_area;
			_tmp5_ = GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->start_editing ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), event, widget, path, &_tmp3_, &_tmp4_, flags);
			_tmp6_ = _g_object_ref0 (_tmp5_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = _tmp6_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Key:
		{
			CellEditableAccel* _tmp7_;
			_tmp7_ = cell_editable_accel_new (self, path, widget);
			g_object_ref_sink (_tmp7_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp7_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Combo:
		{
			gchar** _tmp8_;
			gint _tmp8__length1;
			CellEditableCombo* _tmp9_;
			_tmp8_ = self->items;
			_tmp8__length1 = self->items_length1;
			_tmp9_ = cell_editable_combo_new (self, path, widget, _tmp8_, _tmp8__length1);
			g_object_ref_sink (_tmp9_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp9_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Popup:
		{
			CellEditableDummy* _tmp10_;
			_tmp10_ = cell_editable_dummy_new ();
			g_object_ref_sink (_tmp10_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp10_;
			break;
		}
		default:
		break;
	}
	_tmp11_ = self->priv->cell;
	result = _tmp11_;
	return result;
}

static void
cell_renderer_textish_real_render (GtkCellRenderer* base,
                                   cairo_t* ctx,
                                   GtkWidget* widget,
                                   GdkRectangle* background_area,
                                   GdkRectangle* cell_area,
                                   GtkCellRendererState flags)
{
	CellRendererTextish * self;
	GdkRectangle _tmp0_;
	GdkPixbuf* _tmp1_;
	GdkRectangle _tmp12_;
	GdkRectangle _tmp13_;
	self = (CellRendererTextish*) base;
	g_return_if_fail (ctx != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (background_area != NULL);
	g_return_if_fail (cell_area != NULL);
	_tmp0_ = *cell_area;
	gdk_cairo_rectangle (ctx, &_tmp0_);
	_tmp1_ = self->priv->_icon;
	if (_tmp1_ != NULL) {
		GdkPixbuf* _tmp2_;
		GdkRectangle _tmp3_;
		GdkRectangle _tmp4_;
		GdkRectangle _tmp5_;
		GdkPixbuf* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		GdkPixbuf* _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		_tmp2_ = self->priv->_icon;
		_tmp3_ = *cell_area;
		_tmp4_ = *cell_area;
		_tmp5_ = *cell_area;
		_tmp6_ = self->priv->_icon;
		_tmp7_ = gdk_pixbuf_get_height (_tmp6_);
		_tmp8_ = _tmp7_;
		gdk_cairo_set_source_pixbuf (ctx, _tmp2_, (gdouble) _tmp3_.x, (gdouble) ((_tmp4_.y + (_tmp5_.height / 2)) - (_tmp8_ / 2)));
		cairo_fill (ctx);
		_tmp9_ = self->priv->_icon;
		_tmp10_ = gdk_pixbuf_get_width (_tmp9_);
		_tmp11_ = _tmp10_;
		(*cell_area).x = (*cell_area).x + (_tmp11_ + 4);
	}
	_tmp12_ = *background_area;
	_tmp13_ = *cell_area;
	GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->render ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), ctx, widget, &_tmp12_, &_tmp13_, flags);
}

static void
cell_renderer_textish_real_get_size (GtkCellRenderer* base,
                                     GtkWidget* widget,
                                     GdkRectangle* cell_area,
                                     gint* x_offset,
                                     gint* y_offset,
                                     gint* width,
                                     gint* height)
{
	CellRendererTextish * self;
	gint _vala_x_offset = 0;
	gint _vala_y_offset = 0;
	gint _vala_width = 0;
	gint _vala_height = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	GdkPixbuf* _tmp4_;
	self = (CellRendererTextish*) base;
	g_return_if_fail (widget != NULL);
	GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->get_size ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), widget, cell_area, &_tmp0_, &_tmp1_, &_tmp2_, &_tmp3_);
	_vala_x_offset = _tmp0_;
	_vala_y_offset = _tmp1_;
	_vala_width = _tmp2_;
	_vala_height = _tmp3_;
	_tmp4_ = self->priv->_icon;
	if (_tmp4_ != NULL) {
		GdkPixbuf* _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		GdkPixbuf* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		_tmp5_ = self->priv->_icon;
		_tmp6_ = gdk_pixbuf_get_width (_tmp5_);
		_tmp7_ = _tmp6_;
		_vala_width = _vala_width + _tmp7_;
		_tmp8_ = self->priv->_icon;
		_tmp9_ = gdk_pixbuf_get_height (_tmp8_);
		_tmp10_ = _tmp9_;
		_vala_height = MAX (_vala_height, _tmp10_);
	}
	if (x_offset) {
		*x_offset = _vala_x_offset;
	}
	if (y_offset) {
		*y_offset = _vala_y_offset;
	}
	if (width) {
		*width = _vala_width;
	}
	if (height) {
		*height = _vala_height;
	}
}

static void
cell_renderer_textish_real_get_preferred_height (GtkCellRenderer* base,
                                                 GtkWidget* widget,
                                                 gint* minimum_size,
                                                 gint* natural_size)
{
	CellRendererTextish * self;
	gint _vala_minimum_size = 0;
	gint _vala_natural_size = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	GdkPixbuf* _tmp2_;
	self = (CellRendererTextish*) base;
	g_return_if_fail (widget != NULL);
	GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->get_preferred_height ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), widget, &_tmp0_, &_tmp1_);
	_vala_minimum_size = _tmp0_;
	_vala_natural_size = _tmp1_;
	_tmp2_ = self->priv->_icon;
	if (_tmp2_ != NULL) {
		GdkPixbuf* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		GdkPixbuf* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		_tmp3_ = self->priv->_icon;
		_tmp4_ = gdk_pixbuf_get_height (_tmp3_);
		_tmp5_ = _tmp4_;
		_vala_minimum_size = MAX (_vala_minimum_size, _tmp5_);
		_tmp6_ = self->priv->_icon;
		_tmp7_ = gdk_pixbuf_get_height (_tmp6_);
		_tmp8_ = _tmp7_;
		_vala_natural_size = MAX (_vala_natural_size, _tmp8_);
	}
	if (minimum_size) {
		*minimum_size = _vala_minimum_size;
	}
	if (natural_size) {
		*natural_size = _vala_natural_size;
	}
}

static void
cell_renderer_textish_real_get_preferred_height_for_width (GtkCellRenderer* base,
                                                           GtkWidget* widget,
                                                           gint width,
                                                           gint* minimum_height,
                                                           gint* natural_height)
{
	CellRendererTextish * self;
	gint _vala_minimum_height = 0;
	gint _vala_natural_height = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	GdkPixbuf* _tmp2_;
	self = (CellRendererTextish*) base;
	g_return_if_fail (widget != NULL);
	GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->get_preferred_height_for_width ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), widget, width, &_tmp0_, &_tmp1_);
	_vala_minimum_height = _tmp0_;
	_vala_natural_height = _tmp1_;
	_tmp2_ = self->priv->_icon;
	if (_tmp2_ != NULL) {
		GdkPixbuf* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		GdkPixbuf* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		_tmp3_ = self->priv->_icon;
		_tmp4_ = gdk_pixbuf_get_height (_tmp3_);
		_tmp5_ = _tmp4_;
		_vala_minimum_height = MAX (_vala_minimum_height, _tmp5_);
		_tmp6_ = self->priv->_icon;
		_tmp7_ = gdk_pixbuf_get_height (_tmp6_);
		_tmp8_ = _tmp7_;
		_vala_natural_height = MAX (_vala_natural_height, _tmp8_);
	}
	if (minimum_height) {
		*minimum_height = _vala_minimum_height;
	}
	if (natural_height) {
		*natural_height = _vala_natural_height;
	}
}

static void
cell_renderer_textish_real_get_preferred_width (GtkCellRenderer* base,
                                                GtkWidget* widget,
                                                gint* minimum_size,
                                                gint* natural_size)
{
	CellRendererTextish * self;
	gint _vala_minimum_size = 0;
	gint _vala_natural_size = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	GdkPixbuf* _tmp2_;
	self = (CellRendererTextish*) base;
	g_return_if_fail (widget != NULL);
	GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->get_preferred_width ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), widget, &_tmp0_, &_tmp1_);
	_vala_minimum_size = _tmp0_;
	_vala_natural_size = _tmp1_;
	_tmp2_ = self->priv->_icon;
	if (_tmp2_ != NULL) {
		GdkPixbuf* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		GdkPixbuf* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		_tmp3_ = self->priv->_icon;
		_tmp4_ = gdk_pixbuf_get_width (_tmp3_);
		_tmp5_ = _tmp4_;
		_vala_minimum_size = _vala_minimum_size + _tmp5_;
		_tmp6_ = self->priv->_icon;
		_tmp7_ = gdk_pixbuf_get_width (_tmp6_);
		_tmp8_ = _tmp7_;
		_vala_natural_size = _vala_natural_size + _tmp8_;
	}
	if (minimum_size) {
		*minimum_size = _vala_minimum_size;
	}
	if (natural_size) {
		*natural_size = _vala_natural_size;
	}
}

static void
cell_renderer_textish_real_get_preferred_width_for_height (GtkCellRenderer* base,
                                                           GtkWidget* widget,
                                                           gint height,
                                                           gint* minimum_width,
                                                           gint* natural_width)
{
	CellRendererTextish * self;
	gint _vala_minimum_width = 0;
	gint _vala_natural_width = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	GdkPixbuf* _tmp2_;
	self = (CellRendererTextish*) base;
	g_return_if_fail (widget != NULL);
	GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->get_preferred_width_for_height ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), widget, height, &_tmp0_, &_tmp1_);
	_vala_minimum_width = _tmp0_;
	_vala_natural_width = _tmp1_;
	_tmp2_ = self->priv->_icon;
	if (_tmp2_ != NULL) {
		GdkPixbuf* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		GdkPixbuf* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		_tmp3_ = self->priv->_icon;
		_tmp4_ = gdk_pixbuf_get_width (_tmp3_);
		_tmp5_ = _tmp4_;
		_vala_minimum_width = _vala_minimum_width + _tmp5_;
		_tmp6_ = self->priv->_icon;
		_tmp7_ = gdk_pixbuf_get_width (_tmp6_);
		_tmp8_ = _tmp7_;
		_vala_natural_width = _vala_natural_width + _tmp8_;
	}
	if (minimum_width) {
		*minimum_width = _vala_minimum_width;
	}
	if (natural_width) {
		*natural_width = _vala_natural_width;
	}
}

GdkPixbuf*
cell_renderer_textish_get_icon (CellRendererTextish* self)
{
	GdkPixbuf* result;
	GdkPixbuf* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_icon;
	result = _tmp0_;
	return result;
}

void
cell_renderer_textish_set_icon (CellRendererTextish* self,
                                GdkPixbuf* value)
{
	GdkPixbuf* old_value;
	g_return_if_fail (self != NULL);
	old_value = cell_renderer_textish_get_icon (self);
	if (old_value != value) {
		GdkPixbuf* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_icon);
		self->priv->_icon = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, cell_renderer_textish_properties[CELL_RENDERER_TEXTISH_ICON_PROPERTY]);
	}
}

static void
g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT (GClosure * closure,
                                                 GValue * return_value,
                                                 guint n_param_values,
                                                 const GValue * param_values,
                                                 gpointer invocation_hint,
                                                 gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_FLAGS_UINT) (gpointer data1, const char* arg_1, guint arg_2, guint arg_3, gpointer data2);
	register GMarshalFunc_VOID__STRING_FLAGS_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_FLAGS_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_flags (param_values + 2), g_value_get_uint (param_values + 3), data2);
}

static void
g_cclosure_user_marshal_VOID__STRING_UINT (GClosure * closure,
                                           GValue * return_value,
                                           guint n_param_values,
                                           const GValue * param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_UINT) (gpointer data1, const char* arg_1, guint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_uint (param_values + 2), data2);
}

static void
cell_renderer_textish_class_init (CellRendererTextishClass * klass,
                                  gpointer klass_data)
{
	cell_renderer_textish_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellRendererTextish_private_offset);
	((GtkCellRendererClass *) klass)->start_editing = (GtkCellEditable* (*) (GtkCellRenderer*, GdkEvent*, GtkWidget*, const gchar*, GdkRectangle*, GdkRectangle*, GtkCellRendererState)) cell_renderer_textish_real_start_editing;
	((GtkCellRendererClass *) klass)->render = (void (*) (GtkCellRenderer*, cairo_t*, GtkWidget*, GdkRectangle*, GdkRectangle*, GtkCellRendererState)) cell_renderer_textish_real_render;
	((GtkCellRendererClass *) klass)->get_size = (void (*) (GtkCellRenderer*, GtkWidget*, GdkRectangle*, gint*, gint*, gint*, gint*)) cell_renderer_textish_real_get_size;
	((GtkCellRendererClass *) klass)->get_preferred_height = (void (*) (GtkCellRenderer*, GtkWidget*, gint*, gint*)) cell_renderer_textish_real_get_preferred_height;
	((GtkCellRendererClass *) klass)->get_preferred_height_for_width = (void (*) (GtkCellRenderer*, GtkWidget*, gint, gint*, gint*)) cell_renderer_textish_real_get_preferred_height_for_width;
	((GtkCellRendererClass *) klass)->get_preferred_width = (void (*) (GtkCellRenderer*, GtkWidget*, gint*, gint*)) cell_renderer_textish_real_get_preferred_width;
	((GtkCellRendererClass *) klass)->get_preferred_width_for_height = (void (*) (GtkCellRenderer*, GtkWidget*, gint, gint*, gint*)) cell_renderer_textish_real_get_preferred_width_for_height;
	G_OBJECT_CLASS (klass)->get_property = _vala_cell_renderer_textish_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_cell_renderer_textish_set_property;
	G_OBJECT_CLASS (klass)->finalize = cell_renderer_textish_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CELL_RENDERER_TEXTISH_ICON_PROPERTY, cell_renderer_textish_properties[CELL_RENDERER_TEXTISH_ICON_PROPERTY] = g_param_spec_object ("icon", "icon", "icon", gdk_pixbuf_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL] = g_signal_new ("key-edited", TYPE_CELL_RENDERER_TEXTISH, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT, G_TYPE_NONE, 3, G_TYPE_STRING, gdk_modifier_type_get_type (), G_TYPE_UINT);
	cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL] = g_signal_new ("combo-edited", TYPE_CELL_RENDERER_TEXTISH, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_UINT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_UINT);
}

static void
cell_renderer_textish_instance_init (CellRendererTextish * self,
                                     gpointer klass)
{
	self->priv = cell_renderer_textish_get_instance_private (self);
	self->priv->_icon = NULL;
}

static void
cell_renderer_textish_finalize (GObject * obj)
{
	CellRendererTextish * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_RENDERER_TEXTISH, CellRendererTextish);
	_g_object_unref0 (self->priv->_icon);
	_g_object_unref0 (self->priv->cell);
	G_OBJECT_CLASS (cell_renderer_textish_parent_class)->finalize (obj);
}

static GType
cell_renderer_textish_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellRendererTextishClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_renderer_textish_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellRendererTextish), 0, (GInstanceInitFunc) cell_renderer_textish_instance_init, NULL };
	GType cell_renderer_textish_type_id;
	cell_renderer_textish_type_id = g_type_register_static (gtk_cell_renderer_text_get_type (), "CellRendererTextish", &g_define_type_info, 0);
	CellRendererTextish_private_offset = g_type_add_instance_private (cell_renderer_textish_type_id, sizeof (CellRendererTextishPrivate));
	return cell_renderer_textish_type_id;
}

GType
cell_renderer_textish_get_type (void)
{
	static volatile gsize cell_renderer_textish_type_id__once = 0;
	if (g_once_init_enter (&cell_renderer_textish_type_id__once)) {
		GType cell_renderer_textish_type_id;
		cell_renderer_textish_type_id = cell_renderer_textish_get_type_once ();
		g_once_init_leave (&cell_renderer_textish_type_id__once, cell_renderer_textish_type_id);
	}
	return cell_renderer_textish_type_id__once;
}

static void
_vala_cell_renderer_textish_get_property (GObject * object,
                                          guint property_id,
                                          GValue * value,
                                          GParamSpec * pspec)
{
	CellRendererTextish * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_RENDERER_TEXTISH, CellRendererTextish);
	switch (property_id) {
		case CELL_RENDERER_TEXTISH_ICON_PROPERTY:
		g_value_set_object (value, cell_renderer_textish_get_icon (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_cell_renderer_textish_set_property (GObject * object,
                                          guint property_id,
                                          const GValue * value,
                                          GParamSpec * pspec)
{
	CellRendererTextish * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_RENDERER_TEXTISH, CellRendererTextish);
	switch (property_id) {
		case CELL_RENDERER_TEXTISH_ICON_PROPERTY:
		cell_renderer_textish_set_icon (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
cell_editable_dummy_get_instance_private (CellEditableDummy* self)
{
	return G_STRUCT_MEMBER_P (self, CellEditableDummy_private_offset);
}

static void
cell_editable_dummy_real_start_editing (CellEditableDummy* self,
                                        GdkEvent* event)
{
	gtk_cell_editable_editing_done ((GtkCellEditable*) self);
	gtk_cell_editable_remove_widget ((GtkCellEditable*) self);
}

void
cell_editable_dummy_start_editing (CellEditableDummy* self,
                                   GdkEvent* event)
{
	CellEditableDummyClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = CELL_EDITABLE_DUMMY_GET_CLASS (self);
	if (_klass_->start_editing) {
		_klass_->start_editing (self, event);
	}
}

CellEditableDummy*
cell_editable_dummy_construct (GType object_type)
{
	CellEditableDummy * self = NULL;
	self = (CellEditableDummy*) g_object_new (object_type, NULL);
	return self;
}

CellEditableDummy*
cell_editable_dummy_new (void)
{
	return cell_editable_dummy_construct (TYPE_CELL_EDITABLE_DUMMY);
}

gboolean
cell_editable_dummy_get_editing_canceled (CellEditableDummy* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_editing_canceled;
	return result;
}

void
cell_editable_dummy_set_editing_canceled (CellEditableDummy* self,
                                          gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = cell_editable_dummy_get_editing_canceled (self);
	if (old_value != value) {
		self->priv->_editing_canceled = value;
		g_object_notify_by_pspec ((GObject *) self, cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY]);
	}
}

static void
cell_editable_dummy_class_init (CellEditableDummyClass * klass,
                                gpointer klass_data)
{
	cell_editable_dummy_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellEditableDummy_private_offset);
	((CellEditableDummyClass *) klass)->start_editing = (void (*) (CellEditableDummy*, GdkEvent*)) cell_editable_dummy_real_start_editing;
	G_OBJECT_CLASS (klass)->get_property = _vala_cell_editable_dummy_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_cell_editable_dummy_set_property;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_dummy_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY, cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY] = g_param_spec_boolean ("editing-canceled", "editing-canceled", "editing-canceled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
cell_editable_dummy_gtk_cell_editable_interface_init (GtkCellEditableIface * iface,
                                                      gpointer iface_data)
{
	cell_editable_dummy_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_dummy_start_editing;
}

static void
cell_editable_dummy_instance_init (CellEditableDummy * self,
                                   gpointer klass)
{
	self->priv = cell_editable_dummy_get_instance_private (self);
}

static void
cell_editable_dummy_finalize (GObject * obj)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	G_OBJECT_CLASS (cell_editable_dummy_parent_class)->finalize (obj);
}

static GType
cell_editable_dummy_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellEditableDummyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_dummy_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableDummy), 0, (GInstanceInitFunc) cell_editable_dummy_instance_init, NULL };
	static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_dummy_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType cell_editable_dummy_type_id;
	cell_editable_dummy_type_id = g_type_register_static (gtk_event_box_get_type (), "CellEditableDummy", &g_define_type_info, 0);
	g_type_add_interface_static (cell_editable_dummy_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
	CellEditableDummy_private_offset = g_type_add_instance_private (cell_editable_dummy_type_id, sizeof (CellEditableDummyPrivate));
	return cell_editable_dummy_type_id;
}

GType
cell_editable_dummy_get_type (void)
{
	static volatile gsize cell_editable_dummy_type_id__once = 0;
	if (g_once_init_enter (&cell_editable_dummy_type_id__once)) {
		GType cell_editable_dummy_type_id;
		cell_editable_dummy_type_id = cell_editable_dummy_get_type_once ();
		g_once_init_leave (&cell_editable_dummy_type_id__once, cell_editable_dummy_type_id);
	}
	return cell_editable_dummy_type_id__once;
}

static void
_vala_cell_editable_dummy_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	switch (property_id) {
		case CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY:
		g_value_set_boolean (value, cell_editable_dummy_get_editing_canceled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_cell_editable_dummy_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	switch (property_id) {
		case CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY:
		cell_editable_dummy_set_editing_canceled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
cell_editable_accel_get_instance_private (CellEditableAccel* self)
{
	return G_STRUCT_MEMBER_P (self, CellEditableAccel_private_offset);
}

static void
_cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done (GtkCellEditable* _sender,
                                                                     gpointer self)
{
	cell_editable_accel_on_editing_done ((CellEditableAccel*) self);
}

CellEditableAccel*
cell_editable_accel_construct (GType object_type,
                               CellRendererTextish* parent,
                               const gchar* path,
                               GtkWidget* widget)
{
	CellEditableAccel * self = NULL;
	CellRendererTextish* _tmp0_;
	gchar* _tmp1_;
	GtkLabel* label = NULL;
	GtkLabel* _tmp2_;
	GtkStyleContext* _tmp3_;
	GdkRGBA _tmp4_ = {0};
	GtkStyleContext* _tmp5_;
	GdkRGBA _tmp6_ = {0};
	g_return_val_if_fail (parent != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (widget != NULL, NULL);
	self = (CellEditableAccel*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (parent);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp0_;
	_tmp1_ = g_strdup (path);
	_g_free0 (self->priv->path);
	self->priv->path = _tmp1_;
	g_signal_connect_object ((GtkCellEditable*) self, "editing-done", (GCallback) _cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done, self, 0);
	_tmp2_ = (GtkLabel*) gtk_label_new ("Key combination...");
	g_object_ref_sink (_tmp2_);
	label = _tmp2_;
	gtk_misc_set_alignment ((GtkMisc*) label, 0.0f, 0.5f);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) label);
	_tmp3_ = gtk_widget_get_style_context (widget);
	gtk_style_context_get_background_color (_tmp3_, GTK_STATE_FLAG_SELECTED, &_tmp4_);
	gtk_widget_override_background_color ((GtkWidget*) self, GTK_STATE_FLAG_NORMAL, &_tmp4_);
	_tmp5_ = gtk_widget_get_style_context (widget);
	gtk_style_context_get_color (_tmp5_, GTK_STATE_FLAG_SELECTED, &_tmp6_);
	gtk_widget_override_color ((GtkWidget*) label, GTK_STATE_FLAG_NORMAL, &_tmp6_);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (label);
	return self;
}

CellEditableAccel*
cell_editable_accel_new (CellRendererTextish* parent,
                         const gchar* path,
                         GtkWidget* widget)
{
	return cell_editable_accel_construct (TYPE_CELL_EDITABLE_ACCEL, parent, path, widget);
}

static gboolean
_cell_editable_accel_on_key_gtk_widget_key_press_event (GtkWidget* _sender,
                                                        GdkEventKey* event,
                                                        gpointer self)
{
	gboolean result;
	result = cell_editable_accel_on_key ((CellEditableAccel*) self, event);
	return result;
}

static void
cell_editable_accel_real_start_editing (CellEditableAccel* self,
                                        GdkEvent* event)
{
	guint32 _tmp0_ = 0U;
	GdkWindow* _tmp1_;
	gtk_grab_add ((GtkWidget*) self);
	if (event != NULL) {
		_tmp0_ = gdk_event_get_time (event);
	} else {
		_tmp0_ = (guint32) GDK_CURRENT_TIME;
	}
	_tmp1_ = gtk_widget_get_window ((GtkWidget*) self);
	gdk_keyboard_grab (_tmp1_, FALSE, _tmp0_);
	input_inhibitor_grab ();
	g_signal_connect_object ((GtkWidget*) self, "key-press-event", (GCallback) _cell_editable_accel_on_key_gtk_widget_key_press_event, self, 0);
}

void
cell_editable_accel_start_editing (CellEditableAccel* self,
                                   GdkEvent* event)
{
	CellEditableAccelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = CELL_EDITABLE_ACCEL_GET_CLASS (self);
	if (_klass_->start_editing) {
		_klass_->start_editing (self, event);
	}
}

static gboolean
cell_editable_accel_on_key (CellEditableAccel* self,
                            GdkEventKey* event)
{
	GdkModifierType mods = 0U;
	CellRendererTextish* _tmp0_;
	const gchar* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	if (event->is_modifier != ((guint) 0)) {
		result = TRUE;
		return result;
	}
	switch (event->keyval) {
		case GDK_KEY_Super_L:
		case GDK_KEY_Super_R:
		case GDK_KEY_Hyper_L:
		case GDK_KEY_Hyper_R:
		{
			result = TRUE;
			return result;
		}
		default:
		break;
	}
	mods = event->state;
	gtk_cell_editable_editing_done ((GtkCellEditable*) self);
	gtk_cell_editable_remove_widget ((GtkCellEditable*) self);
	_tmp0_ = self->priv->parent;
	_tmp1_ = self->priv->path;
	g_signal_emit (_tmp0_, cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL], 0, _tmp1_, mods, (guint) event->hardware_keycode);
	result = TRUE;
	return result;
}

static void
cell_editable_accel_on_editing_done (CellEditableAccel* self)
{
	g_return_if_fail (self != NULL);
	gtk_grab_remove ((GtkWidget*) self);
	gdk_keyboard_ungrab ((guint32) GDK_CURRENT_TIME);
	input_inhibitor_ungrab ();
}

gboolean
cell_editable_accel_get_editing_canceled (CellEditableAccel* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_editing_canceled;
	return result;
}

void
cell_editable_accel_set_editing_canceled (CellEditableAccel* self,
                                          gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = cell_editable_accel_get_editing_canceled (self);
	if (old_value != value) {
		self->priv->_editing_canceled = value;
		g_object_notify_by_pspec ((GObject *) self, cell_editable_accel_properties[CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY]);
	}
}

static void
cell_editable_accel_class_init (CellEditableAccelClass * klass,
                                gpointer klass_data)
{
	cell_editable_accel_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellEditableAccel_private_offset);
	((CellEditableAccelClass *) klass)->start_editing = (void (*) (CellEditableAccel*, GdkEvent*)) cell_editable_accel_real_start_editing;
	G_OBJECT_CLASS (klass)->get_property = _vala_cell_editable_accel_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_cell_editable_accel_set_property;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_accel_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY, cell_editable_accel_properties[CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY] = g_param_spec_boolean ("editing-canceled", "editing-canceled", "editing-canceled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
cell_editable_accel_gtk_cell_editable_interface_init (GtkCellEditableIface * iface,
                                                      gpointer iface_data)
{
	cell_editable_accel_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_accel_start_editing;
}

static void
cell_editable_accel_instance_init (CellEditableAccel * self,
                                   gpointer klass)
{
	self->priv = cell_editable_accel_get_instance_private (self);
}

static void
cell_editable_accel_finalize (GObject * obj)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	_g_object_unref0 (self->priv->parent);
	_g_free0 (self->priv->path);
	G_OBJECT_CLASS (cell_editable_accel_parent_class)->finalize (obj);
}

static GType
cell_editable_accel_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellEditableAccelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_accel_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableAccel), 0, (GInstanceInitFunc) cell_editable_accel_instance_init, NULL };
	static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_accel_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType cell_editable_accel_type_id;
	cell_editable_accel_type_id = g_type_register_static (gtk_event_box_get_type (), "CellEditableAccel", &g_define_type_info, 0);
	g_type_add_interface_static (cell_editable_accel_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
	CellEditableAccel_private_offset = g_type_add_instance_private (cell_editable_accel_type_id, sizeof (CellEditableAccelPrivate));
	return cell_editable_accel_type_id;
}

GType
cell_editable_accel_get_type (void)
{
	static volatile gsize cell_editable_accel_type_id__once = 0;
	if (g_once_init_enter (&cell_editable_accel_type_id__once)) {
		GType cell_editable_accel_type_id;
		cell_editable_accel_type_id = cell_editable_accel_get_type_once ();
		g_once_init_leave (&cell_editable_accel_type_id__once, cell_editable_accel_type_id);
	}
	return cell_editable_accel_type_id__once;
}

static void
_vala_cell_editable_accel_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	switch (property_id) {
		case CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY:
		g_value_set_boolean (value, cell_editable_accel_get_editing_canceled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_cell_editable_accel_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	switch (property_id) {
		case CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY:
		cell_editable_accel_set_editing_canceled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
cell_editable_combo_get_instance_private (CellEditableCombo* self)
{
	return G_STRUCT_MEMBER_P (self, CellEditableCombo_private_offset);
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		CellEditableCombo* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->parent);
		_g_free0 (_data1_->path);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
__lambda4_ (Block1Data* _data1_)
{
	CellEditableCombo* self;
	gint _tmp0_;
	gint _tmp1_;
	self = _data1_->self;
	_tmp0_ = gtk_combo_box_get_active ((GtkComboBox*) self);
	_tmp1_ = _tmp0_;
	g_signal_emit (_data1_->parent, cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL], 0, _data1_->path, (guint) _tmp1_);
}

static void
___lambda4__gtk_combo_box_changed (GtkComboBox* _sender,
                                   gpointer self)
{
	__lambda4_ (self);
}

CellEditableCombo*
cell_editable_combo_construct (GType object_type,
                               CellRendererTextish* parent,
                               const gchar* path,
                               GtkWidget* widget,
                               gchar** items,
                               gint items_length1)
{
	CellEditableCombo * self = NULL;
	Block1Data* _data1_;
	CellRendererTextish* _tmp0_;
	gchar* _tmp1_;
	CellRendererTextish* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (parent != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (widget != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = _g_object_ref0 (parent);
	_g_object_unref0 (_data1_->parent);
	_data1_->parent = _tmp0_;
	_tmp1_ = g_strdup (path);
	_g_free0 (_data1_->path);
	_data1_->path = _tmp1_;
	self = (CellEditableCombo*) g_object_new (object_type, NULL);
	_data1_->self = g_object_ref (self);
	_tmp2_ = _g_object_ref0 (_data1_->parent);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp2_;
	_tmp3_ = g_strdup (_data1_->path);
	_g_free0 (self->priv->path);
	self->priv->path = _tmp3_;
	{
		gchar** item_collection = NULL;
		gint item_collection_length1 = 0;
		gint _item_collection_size_ = 0;
		gint item_it = 0;
		item_collection = items;
		item_collection_length1 = items_length1;
		for (item_it = 0; item_it < item_collection_length1; item_it = item_it + 1) {
			gchar* _tmp4_;
			gchar* item = NULL;
			_tmp4_ = g_strdup (item_collection[item_it]);
			item = _tmp4_;
			{
				const gchar* _tmp5_;
				_tmp5_ = item;
				gtk_combo_box_text_append_text ((GtkComboBoxText*) self, _tmp5_);
				_g_free0 (item);
			}
		}
	}
	g_signal_connect_data ((GtkComboBox*) self, "changed", (GCallback) ___lambda4__gtk_combo_box_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}

CellEditableCombo*
cell_editable_combo_new (CellRendererTextish* parent,
                         const gchar* path,
                         GtkWidget* widget,
                         gchar** items,
                         gint items_length1)
{
	return cell_editable_combo_construct (TYPE_CELL_EDITABLE_COMBO, parent, path, widget, items, items_length1);
}

static void
cell_editable_combo_real_start_editing (CellEditableCombo* self,
                                        GdkEvent* event)
{
	cell_editable_combo_gtk_cell_editable_parent_iface->start_editing ((GtkCellEditable*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_combo_box_text_get_type (), GtkComboBoxText), event);
	gtk_widget_show_all ((GtkWidget*) self);
}

void
cell_editable_combo_start_editing (CellEditableCombo* self,
                                   GdkEvent* event)
{
	CellEditableComboClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = CELL_EDITABLE_COMBO_GET_CLASS (self);
	if (_klass_->start_editing) {
		_klass_->start_editing (self, event);
	}
}

static void
cell_editable_combo_class_init (CellEditableComboClass * klass,
                                gpointer klass_data)
{
	cell_editable_combo_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellEditableCombo_private_offset);
	((CellEditableComboClass *) klass)->start_editing = (void (*) (CellEditableCombo*, GdkEvent*)) cell_editable_combo_real_start_editing;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_combo_finalize;
}

static void
cell_editable_combo_gtk_cell_editable_interface_init (GtkCellEditableIface * iface,
                                                      gpointer iface_data)
{
	cell_editable_combo_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_combo_start_editing;
}

static void
cell_editable_combo_instance_init (CellEditableCombo * self,
                                   gpointer klass)
{
	self->priv = cell_editable_combo_get_instance_private (self);
}

static void
cell_editable_combo_finalize (GObject * obj)
{
	CellEditableCombo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_COMBO, CellEditableCombo);
	_g_object_unref0 (self->priv->parent);
	_g_free0 (self->priv->path);
	G_OBJECT_CLASS (cell_editable_combo_parent_class)->finalize (obj);
}

static GType
cell_editable_combo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellEditableComboClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_combo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableCombo), 0, (GInstanceInitFunc) cell_editable_combo_instance_init, NULL };
	static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_combo_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType cell_editable_combo_type_id;
	cell_editable_combo_type_id = g_type_register_static (gtk_combo_box_text_get_type (), "CellEditableCombo", &g_define_type_info, 0);
	g_type_add_interface_static (cell_editable_combo_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
	CellEditableCombo_private_offset = g_type_add_instance_private (cell_editable_combo_type_id, sizeof (CellEditableComboPrivate));
	return cell_editable_combo_type_id;
}

GType
cell_editable_combo_get_type (void)
{
	static volatile gsize cell_editable_combo_type_id__once = 0;
	if (g_once_init_enter (&cell_editable_combo_type_id__once)) {
		GType cell_editable_combo_type_id;
		cell_editable_combo_type_id = cell_editable_combo_get_type_once ();
		g_once_init_leave (&cell_editable_combo_type_id__once, cell_editable_combo_type_id);
	}
	return cell_editable_combo_type_id__once;
}

